#include <SPI.h>
#include <MFRC522.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SH110X.h>
#include <avr/wdt.h>  // Add watchdog timer control

#define RST_PIN 9
#define SS_PIN 10

Adafruit_SH1106G display(128, 64, &Wire, -1);
MFRC522 mfrc522(SS_PIN, RST_PIN);

bool tagPresent = false;
String lastTagUid = "";

const unsigned char danik_logo [] PROGMEM = {
0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 
	0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 
	0x00, 0x00, 0x00, 0x06, 0x78, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x78, 
	0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x78, 0x00, 0x00, 0x00, 0x03, 0xc0, 
	0x00, 0x00, 0x00, 0x00, 0x06, 0x78, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x78, 0x00, 0x00, 0x03, 0xf3, 0xc0, 0x3f, 0x3c, 0xf3, 0xf8, 0x0f, 0x78, 0x0f, 0xc0, 0x0f, 0xff, 
	0xc0, 0xff, 0xfc, 0xff, 0xfc, 0x0f, 0x78, 0x1f, 0x80, 0x1f, 0xff, 0xc1, 0xff, 0xfc, 0xff, 0xff, 
	0x0f, 0x78, 0x3f, 0x00, 0x3e, 0x1f, 0xc3, 0xe1, 0xfc, 0xfe, 0x1f, 0x0f, 0x78, 0x7c, 0x00, 0x7c, 
	0x0f, 0xc7, 0xc0, 0xfc, 0xf8, 0x07, 0x8f, 0x79, 0xf8, 0x00, 0x78, 0x07, 0xc7, 0x80, 0x7c, 0xf8, 
	0x07, 0x8f, 0x7b, 0xf0, 0x00, 0xf8, 0x03, 0xcf, 0x00, 0x3c, 0xf0, 0x03, 0xcf, 0x7f, 0xe0, 0x00, 
	0xf0, 0x03, 0xcf, 0x00, 0x3c, 0xf0, 0x03, 0xcf, 0x7f, 0xc0, 0x00, 0xf0, 0x03, 0xcf, 0x00, 0x3c, 
	0xf0, 0x03, 0xcf, 0x7f, 0x00, 0x00, 0xf0, 0x03, 0xcf, 0x00, 0x3c, 0xf0, 0x03, 0xcf, 0x7f, 0x00, 
	0x00, 0xf0, 0x03, 0xcf, 0x00, 0x3c, 0xf0, 0x03, 0xcf, 0x7f, 0xc0, 0x00, 0xf0, 0x03, 0xcf, 0x00, 
	0x3c, 0xf0, 0x03, 0xcf, 0x7f, 0xe0, 0x00, 0x78, 0x07, 0xc7, 0x80, 0x7c, 0xf0, 0x03, 0xcf, 0x7b, 
	0xf0, 0x00, 0x7c, 0x0f, 0xc7, 0xc0, 0xfc, 0xf0, 0x03, 0xcf, 0x79, 0xf8, 0x00, 0x3e, 0x1f, 0xc3, 
	0xe1, 0xfc, 0xf0, 0x03, 0xcf, 0x78, 0x7c, 0x00, 0x1f, 0xff, 0xc1, 0xff, 0xfc, 0xf0, 0x03, 0xcf, 
	0x78, 0x3e, 0x00, 0x0f, 0xff, 0xc0, 0xff, 0xfc, 0xf0, 0x03, 0xcf, 0x78, 0x1f, 0x80, 0x03, 0xf3, 
	0xc0, 0x3f, 0x3c, 0xf0, 0x03, 0xcf, 0x78, 0x0f, 0xc0
};

const unsigned char rfidisk_logo[] PROGMEM = {
0xfc, 0x7f, 0x77, 0xe1, 0xc0, 0x1c, 0x00, 0xe6, 0x70, 0x77, 0x31, 0xc0, 0x1c, 0x00, 0xe6, 0x70, 
	0x77, 0x18, 0x00, 0x1c, 0x00, 0xe7, 0x70, 0x77, 0x19, 0xc7, 0x1c, 0xc0, 0xe6, 0x70, 0x77, 0x19, 
	0xcd, 0x9d, 0x80, 0xe6, 0x7f, 0x77, 0x19, 0xdc, 0x1d, 0x80, 0xfc, 0x70, 0x77, 0x19, 0xcf, 0x1f, 
	0x00, 0xec, 0x70, 0x77, 0x19, 0xc7, 0x9f, 0x00, 0xe4, 0x70, 0x77, 0x19, 0xc1, 0x9f, 0x80, 0xe6, 
	0x70, 0x77, 0x31, 0xd9, 0x9d, 0x80, 0xe7, 0x70, 0x77, 0xe1, 0xcf, 0x1c, 0xc0
};

void setup() {
  // Disable watchdog first thing to prevent reboots
  wdt_disable();
  
  Serial.begin(9600);
  
  // Initialize display
  if (!display.begin(0x3C, false)) {
    // If display fails, continue anyway
  }

  // Show boot logo
  display.clearDisplay();
  display.drawBitmap(23, 10, danik_logo, 82, 27, SH110X_WHITE);
  display.drawBitmap(39, 45, rfidisk_logo, 50, 11, SH110X_WHITE);
  display.display();
  delay(2000);
  
  // Initialize RFID
  SPI.begin();
  mfrc522.PCD_Init();

  Serial.println("OK");
}

void updateDisplay(const char* title, const char* subtext, const char* line3, const char* line4) {
  display.clearDisplay();
  display.setTextColor(SH110X_WHITE);
  display.setTextSize(1);

  // Top section (title and subtext)
  display.setCursor(5, 8);
  display.print(title);
  
  display.setCursor(5, 20);
  display.print(subtext);

  // Horizontal divider line
  display.drawLine(0, 32, 128, 32, SH110X_WHITE);

  // Bottom section (line3 and line4)
  display.setCursor(5, 40);
  display.print(line3);
  
  display.setCursor(5, 52);
  display.print(line4);

  display.display();
}

String getTagUid() {
  String uid = "";
  for (byte i = 0; i < mfrc522.uid.size; i++) {
    if (mfrc522.uid.uidByte[i] < 0x10) uid += "0";
    uid += String(mfrc522.uid.uidByte[i], HEX);
  }
  return uid;
}

bool isTagPresent() {
  // Reset the reader
  mfrc522.PCD_Init();
  delay(10);
  
  if (!mfrc522.PICC_IsNewCardPresent()) {
    return false;
  }
  
  if (!mfrc522.PICC_ReadCardSerial()) {
    return false;
  }
  
  return true;
}

void loop() {
  // Reset watchdog timer each loop to prevent timeouts
  wdt_reset();
  
  // Process serial commands immediately
  if (Serial.available() > 0) {
    String cmd = Serial.readStringUntil('\n');
    cmd.trim();
    
    if (cmd.startsWith("D|")) {
      // Parse display command: D|title|subtext|line3|line4
      int p1 = cmd.indexOf('|');
      int p2 = cmd.indexOf('|', p1 + 1);
      int p3 = cmd.indexOf('|', p2 + 1);
      int p4 = cmd.indexOf('|', p3 + 1);
      
      if (p1 != -1 && p2 != -1 && p3 != -1 && p4 != -1) {
        String title = cmd.substring(p1 + 1, p2);
        String subtext = cmd.substring(p2 + 1, p3);
        String line3 = cmd.substring(p3 + 1, p4);
        String line4 = cmd.substring(p4 + 1);
        
        updateDisplay(title.c_str(), subtext.c_str(), line3.c_str(), line4.c_str());
      }
    }
  }

  // Check RFID
  bool currentTagPresent = isTagPresent();
  
  if (currentTagPresent && mfrc522.uid.size > 0) {
    String currentUid = getTagUid();
    
    if (!tagPresent) {
      // New tag detected
      Serial.print("ON:");
      Serial.println(currentUid);
      tagPresent = true;
      lastTagUid = currentUid;
    } else if (currentUid != lastTagUid) {
      // Different tag detected
      Serial.print("OF:");
      Serial.println(lastTagUid);
      Serial.print("ON:");
      Serial.println(currentUid);
      lastTagUid = currentUid;
    }
    mfrc522.PICC_HaltA();
  } else if (tagPresent && !currentTagPresent) {
    // Tag was present but now it's gone
    Serial.print("OF:");
    Serial.println(lastTagUid);
    tagPresent = false;
    lastTagUid = "";
  }

  delay(200);
}